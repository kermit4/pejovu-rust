//use base64::{engine::general_purpose, Engine as _};
use bitvec::prelude::*;
use chrono::{Timelike, Utc};
use env_logger::fmt::TimestampPrecision;
use log::{debug, error, info, log_enabled, trace, warn, Level};
use serde::{Deserialize, Serialize};
use serde_json::{json, Value};
use serde_with::{base64::Base64, serde_as};
use sha2::{Digest, Sha256};
use snow::{Builder, Keypair};
use std::cmp;
use std::collections::{HashMap, HashSet};
use std::io::{self, BufReader, BufWriter, Seek, SeekFrom, Write};
//use std::convert::TryInto;
use std::env;
//use std::fmt;
use std::f64;
use std::fs;
use std::fs::File;
use std::fs::OpenOptions;
//use std::io::copy;
use std::net::{SocketAddr, UdpSocket};
use std::os::unix::fs::FileExt;
//use std::path::Path;
use rand::Rng;
use std::str;
use std::time::{Duration, Instant};
use std::vec;

macro_rules! BLOCK_SIZE {
    () => {
        0x1000 // 4k
    };
}

// when this gets to millions of peers, consider keeping less info about the slower ones
#[serde_as]
#[derive(Clone, Serialize, Deserialize, Debug)]
struct PeerInfo {
    delay: Duration,
    anti_ip_spoofing_token_they_expect: Value,
    anti_ip_spoofing_token_i_expect: u32, // to save memory, these could be generated by hashing
    // their host:port with a random unique to this node
    #[serde_as(as = "Base64")]
    public_key: Vec<u8>,
}
impl PeerInfo {
    fn new() -> PeerInfo {
        return PeerInfo {
            delay: Duration::new(0, 200_000_000),
            anti_ip_spoofing_token_they_expect: json!({}),
            anti_ip_spoofing_token_i_expect: rand::thread_rng().gen(),
            public_key: vec![],
        };
    }
}
struct PeerState {
    peer_map: HashMap<SocketAddr, PeerInfo>,
    peer_vec: Vec<SocketAddr>,
    socket: UdpSocket,
    boot: Instant,
    keypair: Keypair,
}
impl PeerState {
    fn always_returned(&self, sa: SocketAddr) -> Vec<Value> {
        debug!("always_returned for {sa}");
        match self.peer_map.get(&sa) {
            None => return vec![],
            Some(p) => {
                let key = p.anti_ip_spoofing_token_they_expect.to_owned();
                if key == json!({}) {
                    return vec![];
                }
                debug!("always_returned for {sa} found {key}");
                return vec![
                    serde_json::json!({"AlwaysReturned": self.peer_map .get(&sa) .unwrap() .anti_ip_spoofing_token_they_expect }),
                ];
            }
        }
    }

    fn probe_interfaces(&mut self) -> () {
        let to_probe: &mut HashSet<SocketAddr> = &mut HashSet::new();
        let addrs = nix::ifaddrs::getifaddrs().unwrap();
        for ifaddr in addrs {
            match ifaddr.address {
                Some(address) => match address.as_sockaddr_in() {
                    Some(addr) => {
                        let mut sa = SocketAddr::from(*addr);
                        sa.set_port(24254);
                        debug!("found local interface {:?}", sa);
                        if !self.peer_map.contains_key(&sa) {
                            self.peer_map.insert(sa, PeerInfo::new());
                        }
                        ()
                    }
                    None => (),
                },
                None => (),
            }
            match ifaddr.broadcast {
                Some(address) => match address.as_sockaddr_in() {
                    Some(addr) => {
                        let mut sa = SocketAddr::from(*addr);
                        sa.set_port(24254);
                        to_probe.insert(sa);
                        ()
                    }
                    None => (),
                },
                None => (),
            }
        }
        to_probe.insert("224.0.0.1:24254".parse().unwrap());
        for sa in to_probe.iter() {
            let mut message_out: Vec<Message> = Vec::new();
            message_out.push(Message::PleaseSendPeers(PleaseSendPeers {})); // let people know im here
            let message_out_bytes: Vec<u8> = serde_json::to_vec(&message_out).unwrap();
            debug!(
                "sending message {:?} to {sa}",
                String::from_utf8_lossy(&message_out_bytes)
            );
            self.socket.send_to(&message_out_bytes, sa).ok();
        }
    }
    fn probe(&mut self) -> () {
        for sa in self.best_peers(10, 3) {
            let peer_info = self.peer_map.get_mut(&sa).unwrap();
            peer_info.delay = peer_info.delay.saturating_add(peer_info.delay / 20);
            let mut message_out: Vec<Value> = Vec::new();
            message_out
                .push(serde_json::to_value(Message::PleaseSendPeers(PleaseSendPeers {})).unwrap());
            // let people know im here
            // im not sure if anyone cares about all this info from completely random contacts
            message_out.push(
                serde_json::to_value(PleaseAlwaysReturnThisMessage::send_key(&self, sa)).unwrap(),
            );
            message_out.push(
                serde_json::to_value(Message::MyPublicKey(MyPublicKey {
                    ed25519: self.keypair.public.clone(),
                }))
                .unwrap(),
            );
            message_out.extend(self.always_returned(sa));
            message_out.push(
                serde_json::to_value(Message::PleaseReturnThisMessage(PleaseReturnThisMessage {
                    sent_at: self.boot.elapsed().as_secs_f64(),
                }))
                .unwrap(),
            );
            let message_out_bytes: Vec<u8> = serde_json::to_vec(&message_out).unwrap();

            debug!(
                "sending message {:?} to {sa}",
                String::from_utf8_lossy(&message_out_bytes)
            );
            match self.socket.send_to(&message_out_bytes, sa) {
                Ok(s) => trace!("sent {s}"),
                Err(e) => warn!("failed to send {0} {e}", message_out_bytes.len()),
            }
        }
    }

    fn sort(&mut self) -> () {
        let mut peers: Vec<_> = self
            .peer_map
            .iter()
            .map(|(k, v)| (k, v.delay.as_secs_f64()))
            .collect::<Vec<_>>();
        peers.sort_unstable_by(|a, b| a.1.total_cmp(&b.1));
        self.peer_vec = peers.into_iter().map(|(addr, _)| *addr).collect();
    }

    fn load_peers(&mut self) -> () {
        let file = OpenOptions::new().read(true).open("peers.v3.json");
        if file.as_ref().is_ok() && file.as_ref().unwrap().metadata().unwrap().len() > 0 {
            let json: Vec<(SocketAddr, PeerInfo)> =
                serde_json::from_reader(&file.unwrap()).unwrap();
            let before = self.peer_map.len();
            self.peer_map.extend(json);
            info!("loaded {0} peers", self.peer_map.len() - before);
        }
    }
    fn save_peers(&self) -> () {
        debug!("saving peers");
        // not really sure how many, if any, of these peers or fields should be saved, or just a list of host:ips, but for the few users (1) of this so far, might as well save it all
        let mut peers_to_save: Vec<(SocketAddr, PeerInfo)> = Vec::new();
        for i in 0..cmp::min(self.peer_vec.len(), 99) {
            peers_to_save.push((self.peer_vec[i], self.peer_map[&self.peer_vec[i]].clone()))
        }

        OpenOptions::new()
            .create(true)
            .write(true)
            .truncate(true)
            .open("peers.v3.json")
            .unwrap()
            .write_all(&serde_json::to_vec_pretty(&peers_to_save).unwrap())
            .ok();
    }

    fn best_peers(&self, how_many: i32, quality: i32) -> HashSet<SocketAddr> {
        let mut rng = rand::thread_rng();
        let result: &mut HashSet<SocketAddr> = &mut HashSet::new();
        for _ in 0..how_many {
            let i = ((rng.gen_range(0.0..1.0) as f64).powi(quality) * (self.peer_vec.len() as f64))
                as usize;
            if i >= self.peer_vec.len() {
                continue;
            }
            let p = &self.peer_vec[i];
            result.insert(*p);
            trace!(
                "best peer(q:{quality}) {0} {1} {2}",
                i,
                p,
                self.peer_map[p].delay.as_secs_f64()
            );
        }
        result.clone()
    }
}
fn main() -> Result<(), std::io::Error> {
    env_logger::builder()
        .format_timestamp(Some(TimestampPrecision::Millis))
        .init();
    println!("logging level: {}", log::max_level());
    let mut ps: PeerState = PeerState {
        peer_map: HashMap::new(),
        peer_vec: Vec::new(),
        socket: UdpSocket::bind("0.0.0.0:24254")?,
        boot: Instant::now(),
        keypair: Builder::new("Noise_XK_25519_ChaChaPoly_SHA256".parse().unwrap())
            .generate_keypair()
            .unwrap(),
    };
    // ugly    println!("your public ed25519 key for this session is:  {:?}",ps.keypair.public);

    ps.socket.set_broadcast(true).ok();
    for p in ["148.71.89.128:24254", "159.69.54.127:24254"] {
        ps.peer_map.insert(p.parse().unwrap(), PeerInfo::new());
    }
    fs::create_dir("./shared").ok();
    std::env::set_current_dir("./shared").unwrap();
    fs::create_dir("./metadata").ok();
    ps.load_peers();
    let mut args = env::args();
    args.next();
    let mut inbound_states: HashMap<String, InboundState> = HashMap::new();
    for v in args {
        info!("queing inbound file {:?}", v);
        InboundState::new(&mut inbound_states, v.as_str());
    }
    ps.socket.set_read_timeout(Some(Duration::new(1, 0)))?;
    let mut last_maintenance = Instant::now() - Duration::new(9999, 0);
    loop {
        if last_maintenance.elapsed() > Duration::from_secs(1) {
            maintenance(&mut inbound_states, &mut ps);
            last_maintenance = Instant::now();
        }
        let mut buf = [0; 0x10000];
        let (message_len, src) = match ps.socket.recv_from(&mut buf) {
            Ok(_r) => _r,
            Err(_e) => {
                debug!("no messages for a second");
                continue;
            }
        };
        let message_in_bytes = &buf[0..message_len];
        let messages: Vec<Value> = match serde_json::from_slice(message_in_bytes) {
            Ok(_r) => _r,
            _ => {
                warn!(
                    "could not deserialize an incoming message {:?}",
                    String::from_utf8_lossy(message_in_bytes)
                );
                continue;
            }
        };
        trace!(
            "incoming message {:?} from {src}",
            String::from_utf8_lossy(message_in_bytes)
        );
        if !ps.peer_map.contains_key(&src) {
            ps.peer_map.insert(src, PeerInfo::new());
            warn!("new peer spotted {src}");
        };
        // This isn't an arrray of Messages because of the PleaseReturn that I don't know
        // always know the structure of,
        let mut message_out: Vec<Value> = Vec::new();
        debug!("received messages {:?} from {src}", messages.len());
        let mut might_be_ip_spoofing = true;
        for message_in in &messages {
            if (message_in["AlwaysReturned"]) != Value::Null {
                match serde_json::from_value(message_in.clone()) {
                    Ok(t) => match t {
                        Message::AlwaysReturned(t) => {
                            might_be_ip_spoofing = t.check_key(&mut ps, src);
                            trace!("might_be_ip_spoofing? {might_be_ip_spoofing}");
                        }
                        _ => (),
                    },
                    _ => (),
                }
            }
        }

        for message_in in messages {
            if (message_in["PleaseAlwaysReturnThisMessage"]) != Value::Null {
                PleaseAlwaysReturnThisMessage::save_key(
                    &mut ps,
                    src,
                    message_in["PleaseAlwaysReturnThisMessage"].clone(),
                );
                continue;
            }
            if (message_in["PleaseReturnThisMessage"]) != Value::Null {
                // this isn't checked below
                // because we don't know it
                // structure so it may error
                message_out.push(
                    serde_json::json!({"ReturnedMessage":message_in["PleaseReturnThisMessage"]}),
                );
                continue;
            }
            let message_in_enum: Message = match serde_json::from_value(message_in) {
                Ok(_r) => _r,
                _ => {
                    warn!("could not deserialize an incoming message (maybe its one not supported by this implementation).");
                    continue;
                }
            };
            let reply = match message_in_enum {
                Message::PleaseSendPeers(t) => t.send_peers(&ps, might_be_ip_spoofing, src),
                Message::Peers(t) => t.receive_peers(&mut ps),
                Message::PleaseSendContent(t) => {
                    t.send_content(&mut inbound_states, src, might_be_ip_spoofing, &ps)
                }
                Message::Content(t) => t.receive_content(&mut inbound_states, src, &mut ps),
                Message::ReturnedMessage(t) => t.update_round_trip_time(&mut ps, src),
                Message::MaybeTheyHaveSome(t) => {
                    t.add_content_peer_suggestions(&mut ps, &mut inbound_states)
                }
                Message::AlwaysReturned(_) => vec![], // handled before htis loop
                Message::MyPublicKey(t) => t.save_public_key(&mut ps, src),
                // TODO something to prevent someone from just inserting a different key into a communication path
                _ => {
                    warn!("unknown message type ");
                    vec![]
                }
            };
            for m in reply {
                message_out.push(serde_json::to_value(m).unwrap());
            }
        }
        if message_out.len() == 0 {
            continue;
        }
        message_out.extend(ps.always_returned(src));
        let mut message_out_bytes;
        let mut ratio;
        // 20 is IP header, 8 is UDP header
        while {
            message_out_bytes = serde_json::to_vec(&message_out).unwrap();
            ratio = // 20 is IP header, 8 is UDP header
            (message_out_bytes.len() as f64 + 20.0 + 8.0) / (message_len as f64 + 20.0 + 8.0);
            trace!("ratio: {ratio}");
            message_out.len() > 0 && might_be_ip_spoofing && ratio > 2.5
        } {
            debug!("{ratio}x ratio: dropping part of response to unverified source IP, so that you are not used as a flood/stressor/DDOS. {:?} {:?}",
                String::from_utf8_lossy(&message_in_bytes),
                String::from_utf8_lossy(&message_out_bytes)
                );
            message_out.pop();
            if message_out.len() == 0 {
                warn!("and none none left due to ratio!");
            }
        }
        if message_out.len() == 0 {
            continue;
        }
        if !might_be_ip_spoofing {
            trace!(
                "sending message {:?} to {src}",
                String::from_utf8_lossy(&message_out_bytes)
            );
        } else {
            trace!(
                "sending message {:?} to {src} \x1b[7mWITHOUT A KEY\x1b[m",
                String::from_utf8_lossy(&message_out_bytes)
            );
        }
        match ps.socket.send_to(&message_out_bytes, src) {
            Ok(s) => trace!("sent {s}"),
            Err(e) => warn!("failed to send {0} {e}", message_out_bytes.len()),
        }
    }
}

#[derive(Serialize, Deserialize)]
struct Peers {
    peers: HashSet<SocketAddr>,
    //   how_to_add_new_fields_without_error: Option<String>,
}
#[derive(Serialize, Deserialize)]
struct AlwaysReturned {
    key: u32,
}
impl AlwaysReturned {
    fn check_key(&self, ps: &PeerState, src: SocketAddr) -> bool {
        let correct_key = ps
            .peer_map
            .get(&src)
            .unwrap()
            .anti_ip_spoofing_token_i_expect;
        debug!("verified key for {src} is {correct_key}");
        return correct_key != self.key;
    }
}

#[derive(Serialize, Deserialize)]
struct PleaseAlwaysReturnThisMessage {
    key: u32,
}
impl PleaseAlwaysReturnThisMessage {
    fn save_key(ps: &mut PeerState, src: SocketAddr, cookie: Value) {
        debug!("saving key {cookie} for {src}");
        ps.peer_map
            .get_mut(&src)
            .unwrap()
            .anti_ip_spoofing_token_they_expect = cookie;
        debug!("saved key verified {:?}", ps.always_returned(src));
    }
    fn send_key(ps: &PeerState, src: SocketAddr) -> Message {
        let correct_key = ps
            .peer_map
            .get(&src)
            .unwrap()
            .anti_ip_spoofing_token_i_expect;
        return Message::PleaseAlwaysReturnThisMessage(PleaseAlwaysReturnThisMessage {
            key: correct_key,
        });
    }
}

#[derive(Serialize, Deserialize)]
struct PleaseSendPeers {}
impl PleaseSendPeers {
    fn send_peers(
        &self,
        ps: &PeerState,
        might_be_ip_spoofing: bool,
        src: SocketAddr,
    ) -> Vec<Message> {
        let p = ps.best_peers(2 + 45 * !might_be_ip_spoofing as i32, 6);
        trace!(
            "sending {:?}/{:?} peers {:?}",
            p.len(),
            ps.peer_map.len(),
            p
        );
        debug!("sending {:?}/{:?} peers", p.len(), ps.peer_map.len());
        let mut message_out = vec![Message::Peers(Peers { peers: p })];
        if might_be_ip_spoofing {
            message_out.push(PleaseAlwaysReturnThisMessage::send_key(&ps, src));
        }
        return message_out;
    }
}

impl Peers {
    fn receive_peers(&self, ps: &mut PeerState) -> Vec<Message> {
        trace!("received peers {:?} ", self.peers.len());
        for p in &self.peers {
            let sa: SocketAddr = *p;
            if !ps.peer_map.contains_key(&sa) {
                trace!("new peer suggested {sa}");
                ps.peer_map.insert(sa, PeerInfo::new());
            }
        }
        return vec![];
    }
}

#[derive(Serialize, Deserialize)]
struct PleaseSendContent {
    id: String,
    length: usize,
    offset: usize,
}

#[serde_as]
#[derive(Serialize, Deserialize)]
struct Content {
    id: String,
    offset: usize,
    #[serde_as(as = "Base64")]
    base64: Vec<u8>,
    eof: Option<usize>,
}

impl PleaseSendContent {
    fn send_content(
        &self,
        inbound_states: &mut HashMap<String, InboundState>,
        src: SocketAddr,
        might_be_ip_spoofing: bool,
        ps: &PeerState,
    ) -> Vec<Message> {
        if self.id.find("/") != None || self.id.find("\\") != None {
            return vec![];
        };
        let mut length = self.length;
        if length > 0xa000 {
            length = 0xa000;
        }
        if might_be_ip_spoofing {
            length = 1; // just to show i have some in a search as they'll have the key next request
            if (rand::thread_rng().gen::<u32>() % 31) == 0 {
                return vec![]; // in case its a client that completel doesn't support
                               // might_be_ip_spoofing so
                               // it doesn't just loop asking for the same block forever
            }
        }

        let mut message_out: Vec<Message> = Vec::new();
        if inbound_states.contains_key(&self.id) {
            let i = inbound_states.get_mut(&self.id).unwrap();
            i.peers.insert(src);
            message_out.append(&mut i.send_transfer_peers(might_be_ip_spoofing));
            // don't proceed to try to send out a file we're downloading even if we have it, as thats probably some testing situation not a real world situation
            if might_be_ip_spoofing {
                message_out.push(PleaseAlwaysReturnThisMessage::send_key(&ps, src));
            }
            return message_out;
        }
        match File::open(&self.id) {
            Err(_) => {
                if might_be_ip_spoofing {
                    message_out.push(PleaseAlwaysReturnThisMessage::send_key(&ps, src));
                }
                return message_out;
            }
            Ok(file) => {
                // TODO even if we dont have and arent downloading the file, maybe we should be nice and keep track
                // of who's been looking and send them MaybeTheyHaveSome ..they would really
                // appreciate it i'm sure, and costs us very little

                debug!(
                    "going to send {:?} at {:?} to {:?}",
                    self.id,
                    self.offset / BLOCK_SIZE!(),
                    src
                );

                let mut buf = vec![0; length];
                length = file.read_at(&mut buf, self.offset as u64).unwrap();
                let (content, _) = buf.split_at(length);
                message_out.push(Message::Content(Content {
                    id: self.id.clone(),
                    offset: self.offset,
                    base64: content.to_vec(),
                    eof: Some(file.metadata().unwrap().len() as usize),
                }));
            }
        }
        if message_out.len() == 0 || !might_be_ip_spoofing {
            message_out.append(&mut InboundState::send_transfer_peers_from_disk(
                &self.id,
                &src,
                might_be_ip_spoofing,
            ));
        }
        if message_out.len() > 0 && might_be_ip_spoofing {
            message_out.push(PleaseAlwaysReturnThisMessage::send_key(&ps, src));
        }
        return message_out;
    }
}

impl Content {
    fn receive_content(
        &self,
        inbound_states: &mut HashMap<String, InboundState>,
        src: SocketAddr,
        ps: &mut PeerState,
    ) -> Vec<Message> {
        if !inbound_states.contains_key(&self.id) {
            info!(
                "unwanted content, probably dups -- the tail still in flight after completion, for {0} block {1}",
                self.id,
                self.offset / BLOCK_SIZE!());
            return vec![];
        }
        let mut message_out;
        let i = inbound_states.get_mut(&self.id).unwrap();
        i.peers.insert(src);
        let block_number = self.offset / BLOCK_SIZE!();
        debug!(
            "\x1b[34mreceived block {:?} {:?} {:?} from {:?} window \x1b[7m{:}\x1b[m",
            self.id,
            block_number,
            block_number * BLOCK_SIZE!(),
            src,
            i.next_block as i64 - block_number as i64
        );
        let this_eof = match self.eof {
            Some(n) => {
                debug!("got eof {:?}", n);
                n
            }
            None => self.offset + self.base64.len() + 1,
        };

        if this_eof != i.eof {
            i.eof = this_eof;
            let blocks = (i.eof + BLOCK_SIZE!() - 1) / BLOCK_SIZE!();
            i.bitmap.resize(blocks, false);
        }

        if i.bitmap[block_number] {
            info!("dup {block_number}");
            return vec![];
        }
        let good_block =
            self.base64.len() == BLOCK_SIZE!() || self.base64.len() + self.offset == i.eof;
        if good_block {
            if i.file.is_none() {
                if i.last_activity > Instant::now() {
                    // must be a delayed restart due to a failed hash
                    warn!("delaying restart!");
                    return vec![];
                }
                debug!("{}  opening file!", i.id);
                i.file = Some(
                    OpenOptions::new()
                        .create(true)
                        .read(true)
                        .write(true)
                        .open("./incoming/".to_owned() + &i.id)
                        .unwrap(),
                )
            }
            i.file
                .as_mut()
                .unwrap()
                .write_at(&self.base64, self.offset as u64)
                .unwrap();
            i.bytes_complete += self.base64.len();
            i.bitmap.set(block_number, true);
        }
        i.last_activity = Instant::now();
        message_out = i.request_next_block();
        if good_block {
            i.next_block += 1;
        }
        if (rand::thread_rng().gen::<u32>() % 101) == 0 {
            for (_, i) in inbound_states.iter_mut() {
                if i.next_block * BLOCK_SIZE!() >= i.eof {
                    continue;
                }
                debug!("growing window for {0}", i.id);
                i.request_blocks(ps, HashSet::from([src]));
                i.next_block += 1;
                break;
            }
        }
        let i = inbound_states.get_mut(&self.id).unwrap();
        if i.bytes_complete == i.eof {
            // yes this could sha as it goes, but then its not testing as much as it could, for
            // little real improvement, so dont do that
            let mut hasher = Sha256::new();
            io::copy(i.file.as_mut().unwrap(), &mut hasher).ok();
            let hash = format!("{:x}", hasher.finalize());
            info!("{} sha256sum", hash);
            if hash == i.id.to_lowercase() {
                info!("{0} finished {1} bytes", i.id, i.eof);
                println!("{0} finished {1} bytes", i.id, i.eof);
                let path = "./incoming/".to_owned() + &i.id;
                let new_path = "./".to_owned() + &i.id;
                fs::rename(path, new_path).unwrap();
                i.save_transfer_peers();
                inbound_states.remove(&self.id);
            } else {
                error!(
                    "{} hash doesnt match! restarting, after a large delay",
                    i.id
                );
                i.bitmap.fill(false);
                i.next_block = 0;
                i.bytes_complete = 0;
                i.last_activity = Instant::now() + Duration::new(999, 00);
                i.file = None;
                return vec![];
            };
        }
        if message_out.len() == 0 {
            for (_, i) in inbound_states.iter_mut() {
                if i.next_block * BLOCK_SIZE!() >= i.eof {
                    continue;
                }
                message_out = i.request_next_block();
                i.next_block += 1;
                break;
            }
        }
        match inbound_states.get_mut(&self.id) {
            None => (),
            Some(i) => {
                if message_out.len() == 0 {
                    i.next_block = 0;
                    message_out = i.request_next_block();
                    i.next_block += 1;
                }
            }
        }
        return message_out;
    }
}
//
struct InboundState {
    file: Option<File>,
    next_block: usize,
    bitmap: BitVec,
    id: String,
    eof: usize,
    bytes_complete: usize,
    peers: HashSet<SocketAddr>,
    last_activity: Instant,
}

impl InboundState {
    fn new(inbound_states: &mut HashMap<String, InboundState>, id: &str) -> () {
        fs::create_dir("./incoming").ok();
        let mut i = InboundState {
            file: None,
            next_block: 0,
            bitmap: BitVec::new(),
            id: id.to_string(),
            eof: 1 << 18,
            bytes_complete: 0,
            peers: HashSet::new(),
            last_activity: Instant::now() - Duration::new(999, 00),
        };
        i.bitmap
            .resize((i.eof + BLOCK_SIZE!() - 1) / BLOCK_SIZE!(), false);
        inbound_states.insert(id.to_string(), i);
    }

    fn request_next_block(&mut self) -> Vec<Message> {
        while {
            if self.next_block * BLOCK_SIZE!() >= self.eof {
                // %EOF
                info!(
                    "\x1b[36m{} almost done {}/{} blocks done/remaining (eof: {})  \x1b[m",
                    self.id,
                    self.bytes_complete / BLOCK_SIZE!(),
                    (self.eof - self.bytes_complete) / BLOCK_SIZE!(),
                    self.eof,
                );

                if log_enabled!(Level::Trace) {
                    // this can cause window loss in debug build
                    for i in self.bitmap.iter_zeros() {
                        trace!("{i}");
                    }
                }

                //                self.next_block = 0;
                return vec![];
            }
            self.bitmap[self.next_block]
        } {
            self.next_block += 1;
        }
        debug!(
            "\x1b[32;7mPleaseSendContent {} {} {} \x1b[m",
            self.id,
            self.next_block,
            self.next_block * BLOCK_SIZE!()
        );
        self.last_activity = Instant::now();
        let message_out = vec![Message::PleaseSendContent(PleaseSendContent {
            id: self.id.to_owned(),
            offset: self.next_block * BLOCK_SIZE!(),
            length: BLOCK_SIZE!(),
        })];
        return message_out;
    }
    fn request_blocks(&mut self, ps: &mut PeerState, some_peers: HashSet<SocketAddr>) {
        for sa in some_peers {
            let mut message_out: Vec<Value> = Vec::new();
            for m in self.request_next_block() {
                message_out.push(serde_json::to_value(m).unwrap());
            }
            if message_out.len() < 1 {
                return;
            }
            message_out.extend(ps.always_returned(sa));

            let message_out_bytes: Vec<u8> = serde_json::to_vec(&message_out).unwrap();
            debug!(
                "sending message {:?} to {sa}",
                String::from_utf8_lossy(&message_out_bytes)
            );
            ps.socket.send_to(&message_out_bytes, sa).ok();
        }
    }
    fn save_transfer_peers(&self) -> () {
        debug!("saving inbound state peers");
        let filename = "./metadata/".to_owned() + &self.id + ".json";
        OpenOptions::new()
            .create(true)
            .write(true)
            .truncate(true)
            .open(filename)
            .unwrap()
            .write_all(
                serde_json::to_vec_pretty(&json!({"Peers":&self.peers}))
                    .unwrap()
                    .as_slice(),
            )
            .ok();
    }
    fn send_transfer_peers_from_disk(
        id: &String,
        src: &SocketAddr,
        might_be_ip_spoofing: bool,
    ) -> Vec<Message> {
        let filename = "./metadata/".to_owned() + &id + ".json";
        let mut file = OpenOptions::new()
            .create(true)
            .write(true)
            .read(true)
            .truncate(false)
            .open(filename)
            .unwrap();

        let peers: &mut HashSet<SocketAddr> = &mut HashSet::new();
        if file.metadata().unwrap().len() > 0 {
            let json: serde_json::Value = serde_json::from_reader(BufReader::new(&file)).unwrap();
            let loaded_peers: HashSet<SocketAddr> =
                serde_json::from_value(json["Peers"].clone()).unwrap();
            peers.extend(loaded_peers);
        }
        if peers.insert(*src) {
            file.seek(SeekFrom::Start(0)).ok();
            serde_json::to_writer_pretty(BufWriter::new(file), &json!({"Peers":&peers})).unwrap();
        }
        if peers.len() == 0 {
            return vec![];
        }
        let at_most = 3 + 45 * !might_be_ip_spoofing as usize;

        return vec![Message::MaybeTheyHaveSome(MaybeTheyHaveSome {
            id: id.to_owned(),
            peers: peers.iter().take(at_most).cloned().collect(),
        })];
    }
    fn send_transfer_peers(&self, might_be_ip_spoofing: bool) -> Vec<Message> {
        debug!("{} sending peers", self.id);
        let at_most = 3 + 45 * !might_be_ip_spoofing as usize;
        return vec![Message::MaybeTheyHaveSome(MaybeTheyHaveSome {
            id: self.id.clone(),
            peers: self.peers.iter().take(at_most).cloned().collect(),
        })];
    }
}

fn maintenance(inbound_states: &mut HashMap<String, InboundState>, ps: &mut PeerState) -> () {
    ps.sort();
    if Utc::now().second() / 3 + (Utc::now().minute() % 5) == 0 {
        ps.save_peers();
    }
    ps.probe_interfaces();
    ps.probe();
    for (_, i) in inbound_states.iter_mut() {
        if i.last_activity.elapsed() > Duration::from_secs(1) && i.next_block != 0 {
            debug!("stalled {}", i.id);
            i.next_block = 0; // start over to catch any lost packets, as now we know there's
                              // probably not any still in flight
        }
    }
    for (_, i) in inbound_states.iter_mut() {
        if i.last_activity.elapsed() > Duration::from_secs(1) {
            debug!("restarting {}", i.id);
            i.request_blocks(ps, i.peers.clone()); // resume (un-stall)
        }
        if i.last_activity <= Instant::now() {
            debug!("searching for {}", i.id);
            i.request_blocks(ps, ps.best_peers(50, 6));
            break; // this is to see how slow it would be if it was streaming new 256k created in real
                   // time.  really this should handle many or all at once, but test how well that
                   // works with 10000 at once..first issue is open file handles.  2nd is excessive
                   // paccket loss trying to spark that many at once, so there needs to be some liimt,
                   // but more than one.
        }
    }
}

#[derive(Serialize, Deserialize)]
struct MaybeTheyHaveSome {
    id: String,
    peers: HashSet<SocketAddr>,
}

impl MaybeTheyHaveSome {
    fn add_content_peer_suggestions(
        self,
        ps: &mut PeerState,
        inbound_states: &mut HashMap<String, InboundState>,
    ) -> Vec<Message> {
        if !inbound_states.contains_key(&self.id) {
            return vec![];
        }
        let i = inbound_states.get_mut(&self.id).unwrap();
        for p in self.peers {
            if i.peers.insert(p) {
                // new possible source? try it
                i.request_blocks(ps, HashSet::from([p]));
            }
        }
        return vec![];
    }
}
#[derive(Serialize, Deserialize)]
struct PleaseReturnThisMessage {
    sent_at: f64,
}

#[derive(Serialize, Deserialize)]
struct ReturnedMessage {
    sent_at: f64,
}
impl ReturnedMessage {
    fn update_round_trip_time(&self, ps: &mut PeerState, src: SocketAddr) -> Vec<Message> {
        match ps.peer_map.get_mut(&src) {
            Some(peer) => {
                peer.delay = (ps.boot + Duration::from_secs_f64(self.sent_at)).elapsed();
                trace!("measured {0} at {1}", src, peer.delay.as_secs_f64())
            }
            _ => (),
        };
        return vec![];
    }
}

#[serde_as]
#[derive(Serialize, Deserialize)]
struct MyPublicKey {
    #[serde_as(as = "Base64")]
    ed25519: Vec<u8>,
}
impl MyPublicKey {
    fn save_public_key(&self, ps: &mut PeerState, src: SocketAddr) -> Vec<Message> {
        ps.peer_map.get_mut(&src).unwrap().public_key = self.ed25519.clone();
        return vec![];
    }
}

#[derive(Serialize, Deserialize)]
enum Message {
    PleaseSendPeers(PleaseSendPeers),
    Peers(Peers),
    PleaseSendContent(PleaseSendContent),
    Content(Content),
    PleaseReturnThisMessage(PleaseReturnThisMessage),
    ReturnedMessage(ReturnedMessage),
    MaybeTheyHaveSome(MaybeTheyHaveSome),
    PleaseAlwaysReturnThisMessage(PleaseAlwaysReturnThisMessage),
    AlwaysReturned(AlwaysReturned),
    MyPublicKey(MyPublicKey),
}
